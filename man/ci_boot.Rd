% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions.R
\name{ci_boot}
\alias{ci_boot}
\title{Pasikliautinieji intervalai (PI) savirankos metodais}
\usage{
ci_boot(.data, x, y = NULL, conf.level = 0.95, ...)
}
\arguments{
\item{.data}{Duomenų lentelė.}

\item{x, y}{Stulpelio pavadinimas (be kabučių).}

\item{conf.level}{Pasikliovimo lygmuo. Numatytoji reikšmė – 0.95.}

\item{...}{Kiti parametrai, kuriuos priima \code{\link[DescTools:BootCI]{DescTools::BootCI()}}, tarp kurių:
\enumerate{
\item \code{FUN} -- funkcija, kurios rezultatui skaičiuojami PI.
\item \code{bci.method} -- intervalų sudarymo metodai:
\itemize{
\item \code{"perc"} -- procentilių metodas,
\item \code{"bca"}  -- koreguotasis procentilių metodas BCa
(angl. bias-corrected and accelerated),
\item kiti.
}
\item \code{R} -- replikacijų (pakartojimų) skaičius.
Įprastai turi būti tarp 1'000 ir 10'000.
}}
}
\value{
Rezultatas – duomenų lentelė, su pasikliautinaisiais intervalais.
Stulpelių skaičius ir pavadinimai priklauso nuo funkcijos argumentų reikšmių
ir sugrupavimo:
\itemize{
\item Jei duomenų lentelė grupuotoji, pirmųjų stulpelių pavadinimai sutampa su
grupavimo kintamųjų pavadinimais.
\item Stulpelio pavadinimas, sutampantis su skaičiuojamos statistikos pavadinimu
(argumento \code{FUN} reikšme).
Jame yra skaičiuojamos statistikos įvertis.
\item \code{lwr.ci}, \code{upr.ci} – (lower CI, upper CI) apatinė ir viršutinė
pasikliautinojo intervalo ribos.
}
}
\description{
Pasikliautinųjų intervalų (PI) skaičiavimas pasirinktu savirankos metodu
(angl. \emph{statistical bootstrap}). Funkcija \code{ci_boot()} yra patobulintas
\code{\link[DescTools:BootCI]{DescTools::BootCI()}} variantas. Rezultatas – duomenų lentelė.
}
\details{
Ši funkcija naudojama panašiai, kaip \code{\link[DescTools:BootCI]{DescTools::BootCI()}}, bet:
\itemize{
\item pirmas argumentas yra duomenų lentelė;
\item argumentai \code{x} (ir, jei reikia, \code{y}) – stulpelių pavadinimai – nurodomi
be kabučių;
\item funkcija reaguoja į \code{\link[dplyr:group_by]{dplyr::group_by()}}, tad skaičiavimus gali atlikti
pogrupiams;
\item rezultatas – duomenų lentelė.
Todėl rezultatą galima patogiai braižyti naudojant \pkg{ggplot2}.
}
}
\examples{
data(iris, package = "datasets")
head(iris)

set.seed(1) # Atkartojamumui

# Medianos PI iš 1000 pakartojimų,
# BCa metodas
ci_boot(iris, Petal.Length, FUN = median, R = 1000, bci.method = "bca")

# Naudojamas jungimo operatorius
iris |>
  ci_boot(Petal.Length, FUN = median, R = 1000, bci.method = "bca")

# PI skaičiavimas kiekvienai grupei atskirai
iris |>
  dplyr::group_by(Species) |>
  ci_boot(Petal.Length, FUN = median, R = 1000, bci.method = "bca")

# Medianos PI iš 1000 pakartojimų, procentilių metodas
iris |>
  dplyr::group_by(Species) |>
  ci_boot(Petal.Length, FUN = median, R = 1000, bci.method = "perc")

# PI skaičiavimas, nurodant funkcijos `median()`
# argumentą `na.rm = TRUE`
med_pi_gr <-
  iris |>
  dplyr::group_by(Species) |>
  ci_boot(
    Petal.Length,
    FUN = median, na.rm = TRUE,
    R = 1000, bci.method = "bca"
  )
med_pi_gr

# Dviejų kintamųjų funkcijoms pavyzdys:
# Spearman koreliacijos koeficientas
# (method = "spearman" yra cor() argumentas)
spearman_pi_gr <-
  iris |>
  dplyr::group_by(Species) |>
  ci_boot(
    Petal.Length, Petal.Width,
    FUN = cor, method = "spearman",
    R = 1000, bci.method = "bca"
  )
spearman_pi_gr

# Dviejų kintamųjų funkcijoms pavyzdys:
# Pearson koreliacijos koeficientas
# (method = "pearson" yra cor() argumentas)
pearson_pi_gr <-
  iris |>
  dplyr::group_by(Species) |>
  ci_boot(
    Petal.Length, Petal.Width,
    FUN = cor, method = "pearson",
    R = 1000, bci.method = "bca"
  )
pearson_pi_gr

}
